<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frida on SYM01&#39;s BLOG</title>
    <link>https://sym01.com/tags/frida/</link>
    <description>Recent content in Frida on SYM01&#39;s BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Nov 2019 19:04:29 +0800</lastBuildDate>
    
	<atom:link href="https://sym01.com/tags/frida/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS中利用Frida解密任意APP的流量</title>
      <link>https://sym01.com/posts/2019/ios-debug-encrypted-traffic-with-frida/</link>
      <pubDate>Mon, 04 Nov 2019 19:04:29 +0800</pubDate>
      
      <guid>https://sym01.com/posts/2019/ios-debug-encrypted-traffic-with-frida/</guid>
      <description>0x00 前言 最近测试的APP里，越来越多的APP采用了加密流量的通信方式，即在原有的HTTP、HTTPS流量之上，又做了一层加密。
要对这些加密过程进行逆向，无疑要耗费大量的工作量，时间可能不允许。因此，可采用一种Hook的方式，将加密前/解密后的流量截获下来。
0x01 原理 通过加密流量与远端进行通信，势必会调用响应的加密、解密函数。因此，可通过Frida直接将未加密的流量Hook出来。
然而这样只能查看未加密的流量，不能篡改里边的数据，显然不太使用。因此，我们需要允许用户在流量进行加密/解密时，篡改里边的内容。
实现思路较为简单，如下所示：
 Hook加密函数，中断加密过程，将未加密的数据发送到本地搭建的一个服务器，并将HTTP代理设置为Burpsuite的代理 本地搭建的服务器原封不动地返回请求数据 Hook点收到服务器返回的数据后，利用服务器返回的数据替换原有数据，并恢复加密函数的执行过程 重复1、2、3的步骤，Hook掉解密函数  这样一来，Burpsuite就能够发挥其原有的作用，劫持未加密的流量，并对流量内容进行篡改了。
0x02 实现 以某APP为例，首先起一个echo服务器线程，专门负责原封不动地返回客户端的请求数据；其次用Frida hook掉相关加解密函数，将未加密的流量通过Burpsuite代理发往echo服务器。相关脚本内容如下：
#!/usr/bin/env python3 # coding: utf-8 from time import sleep from threading import Thread from http.server import HTTPServer, BaseHTTPRequestHandler import sys import requests import frida ECHO_PORT = 28080 BURP_PORT = 8080 class RequestHandler(BaseHTTPRequestHandler): def do_REQUEST(self): content_length = int(self.headers.get(&amp;#39;content-length&amp;#39;, 0)) self.send_response(200) self.end_headers() self.wfile.write(self.rfile.read(content_length)) do_RESPONSE = do_REQUEST def echo_server_thread(): print(&amp;#39;start echo server at port {}&amp;#39;.</description>
    </item>
    
  </channel>
</rss>